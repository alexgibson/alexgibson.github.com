<!DOCTYPE html><html lang="en" class="no-js"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><title>Adding a Service Worker to Jekyll – Alex Gibson</title><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="How to integrate a Service Worker in your Jekyll blog to help improve website performance"><meta name="author" content="Alex Gibson"><meta name="generator" content="Jekyll"><link rel="canonical" href="https://alxgbsn.co.uk/2017/12/08/adding-a-service-worker-to-jekyll/"><script type="module">try {
      const currentPref = sessionStorage.getItem('t-dark');
      const prefersDarkMode = currentPref === 'true' || (currentPref !== 'false' && window.matchMedia('(prefers-color-scheme: dark)').matches);

      if (prefersDarkMode) {
          document.documentElement.classList.add('js-t-dark');
      }

      // remove no-js class that supports dark theme with JS disabled.
      document.documentElement.classList.remove('no-js');
    } catch (e) {
      // do nothing.
    }</script><link rel="stylesheet" type="text/css" href="/assets/styles-90602e14f6c8c884c1bf227c31ebc574b5fc6f270296aaec97d707ba3f50f7f9.css"><link rel="alternate" type="application/rss+xml" title="Alex Gibson" href="/feed/"><link rel="manifest" href="/manifest.json"><!--[if lt IE 9]>
    <script type="text/javascript" src="/assets/lib/html5shiv-6e9566e51098627c2824e546909ee18725d233fc9cdd81910819e7e108cf36c0.js"></script>
  <![endif]--><meta name="apple-mobile-web-app-title" content="Alex Gibson"><link rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/avatar-180-b1f192dbbe4ceec9c13c327fb0908af5ddbf621002116885f0cc2e8d8b6787c8.jpg"><link rel="icon" type="image/png" sizes="196x196" href="/assets/avatar-196-a65772ff09fa529d865e4f60735ded2bfb50711bafb1bd79cb2111d7c4ec461c.jpg"><link href="/assets/favicon-28523dd6d2b5917829586fe5248f9a408486e09f98117add94210f56aa7ead33.ico" rel="shortcut icon"></head><body><main role="main"><div class="masthead"><nav role="navigation"><ul><li><a href="/">Home</a></li><li><a href="/about/">About</a></li><li><a href="/contact/">Contact</a></li></ul></nav><div class="theme-selector hidden"><form class="theme-form" method="get"><input type="radio" id="t-light" name="theme" value="t-light" checked="checked"> <label for="t-light" title="Light theme">Light</label> <input type="radio" id="t-dark" name="theme" value="t-dark"> <label for="t-dark" title="Dark theme">Dark</label></form></div></div><article><header role="banner"><h1>Adding a Service Worker to Jekyll</h1></header><section class="post"><p class="meta"><time datetime="2017-12-08">December 08 2017</time> 6 min read.</p><p>Implementing a Service Worker is something I’ve only really <a href="https://github.com/alexgibson/wavepad">toyed with in the past</a>. I recently felt like I needed to get reacquainted with their inner workings again, so I decided to implement one for this blog. Here are some tips and tricks I learned along the way.</p><h2 id="choose-a-caching-strategy">Choose a caching strategy</h2><p>Caching is one of the hardest problems in programming, and also one of the main reasons why service workers can be a bit difficult to understand at first. Choosing the wrong caching strategy for your service worker can lead to unexpected and sometimes difficult to reproduce bugs, so it’s important to spend some time thinking about what will work best for your website.</p><p>The last service worker I wrote used an <em>offline first</em> approach. This worked out OK since it was only a single HTML page with a limited number of static assets. The service worker looked in the cache first for any <code class="highlighter-rouge">GET</code> request, and only went out to the network if there was no match:</p><figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">self</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">'fetch'</span><span class="p">,</span> <span class="nx">event</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">request</span><span class="p">;</span>

    <span class="c1">// Always fetch non-GET requests from the network.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">method</span> <span class="o">!==</span> <span class="s1">'GET'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">event</span><span class="p">.</span><span class="nx">respondWith</span><span class="p">(</span><span class="nx">fetch</span><span class="p">(</span><span class="nx">request</span><span class="p">));</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Look to the cache first, then fall back to the network.</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">respondWith</span><span class="p">(</span>
        <span class="nx">caches</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">request</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">response</span> <span class="o">||</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">request</span><span class="p">);</span>
        <span class="p">})</span>
    <span class="p">);</span>
<span class="p">});</span></code></pre></figure><p>For this blog that’s not really what I wanted though, since when people visit I want to be sure they always see the most recent content straight away. For this reason I went for a <em>network first</em> approach for HTML pages, and falling back to a simple <em>offline</em> page if a request fails:</p><figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">self</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">'fetch'</span><span class="p">,</span> <span class="nx">event</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">request</span><span class="p">;</span>

    <span class="c1">// Always fetch non-GET requests from the network.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">method</span> <span class="o">!==</span> <span class="s1">'GET'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">event</span><span class="p">.</span><span class="nx">respondWith</span><span class="p">(</span><span class="nx">fetch</span><span class="p">(</span><span class="nx">request</span><span class="p">));</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// For HTML requests, try the network first else fall back to the offline page.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="s1">'Accept'</span><span class="p">).</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">'text/html'</span><span class="p">)</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">event</span><span class="p">.</span><span class="nx">respondWith</span><span class="p">(</span>
            <span class="nx">fetch</span><span class="p">(</span><span class="nx">request</span><span class="p">).</span><span class="k">catch</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">caches</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="s1">'/offline/'</span><span class="p">))</span>
        <span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">});</span></code></pre></figure><p>I could have additionally chosen to cache pages that users have already visited, and served those up if the network fails and there is a match in the service worker cache. I’m not convinced however, that my personal blog posts are really interesting enough that people actually want them heavily cached on their hard drives, so for now a simple offline page will suffice ;)</p><h2 id="dealing-with-static-assets">Dealing with static assets</h2><p>In order to get page load performance benefits out of my service worker whilst using a network first strategy for HTML pages, I chose a slightly different strategy for serving static assets such as CSS, JavaScript and image files. Here we look in the service worker cache first and return a response straight away. If no match is found, we go out to the network:</p><figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">self</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">'fetch'</span><span class="p">,</span> <span class="nx">event</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">request</span><span class="p">;</span>

    <span class="c1">// Always fetch non-GET requests from the network.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">method</span> <span class="o">!==</span> <span class="s1">'GET'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">event</span><span class="p">.</span><span class="nx">respondWith</span><span class="p">(</span><span class="nx">fetch</span><span class="p">(</span><span class="nx">request</span><span class="p">));</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// For HTML requests, try the network first else fall back to the offline page.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="s1">'Accept'</span><span class="p">).</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">'text/html'</span><span class="p">)</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">event</span><span class="p">.</span><span class="nx">respondWith</span><span class="p">(</span>
            <span class="nx">fetch</span><span class="p">(</span><span class="nx">request</span><span class="p">).</span><span class="k">catch</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">caches</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="s1">'/offline/'</span><span class="p">))</span>
        <span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// For non-HTML requests, look in the cache first else fall back to the network.</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">respondWith</span><span class="p">(</span>
        <span class="nx">caches</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">request</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">response</span> <span class="o">||</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">request</span><span class="p">);</span>
        <span class="p">})</span>
    <span class="p">);</span>
<span class="p">});</span></code></pre></figure><p>There is a potential issue here however. What if a visitor requests an HTML page, but that page uses updated assets that no longer match what’s stored in the current service worker cache? This could lead to both visual bugs and broken behavior, which is not good. Rather than try to fight against the cache, using immutable assets is a good strategy here.</p><h2 id="immutability-to-the-rescue">Immutability to the rescue!</h2><p>Jekyll doesn’t support immutable assets out-of-the-box, but luckily there is already a plugin called <a href="https://github.com/envygeeks/jekyll-assets">jekyll-assets</a> that can hash asset filenames for you (and more). Once I had this installed, I updated both my liquid templates and my service worker’s <code class="highlighter-rouge">updateStaticCache</code> function to use the hashed filenames. This ensures that my service worker never accidentally responds with an outdated asset that a web page might be using, since the actual file names are individually hashed:</p><figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">updateStaticCache</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">caches</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="nx">cacheName</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">cache</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">addAll</span><span class="p">([</span>
            <span class="s1">'{{ assets['</span><span class="nx">styles</span><span class="p">.</span><span class="nx">scss</span><span class="s1">'].digest_path }}'</span><span class="p">,</span>
            <span class="s1">'{{ assets['</span><span class="nx">main</span><span class="p">.</span><span class="nx">js</span><span class="s1">'].digest_path }}'</span><span class="p">,</span>
            <span class="s1">'{{ assets['</span><span class="nx">avatar</span><span class="o">-</span><span class="mi">180</span><span class="p">.</span><span class="nx">jpg</span><span class="s1">'].digest_path }}'</span><span class="p">,</span>
            <span class="s1">'/offline/'</span>
        <span class="p">]);</span>
    <span class="p">});</span>
<span class="p">}</span></code></pre></figure><p>In order to get Jekyll to parse the JavaScript here, I had to trick it into thinking the file is a piece of YAML front-matter. You can do this by inserting two rows of three dashes at the top of the service worker file. I also used Jekll’s date/time functions to automatically version the Service Worker each time the static site is generated:</p><figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">---</span>
<span class="o">---</span>

<span class="kd">const</span> <span class="nx">version</span> <span class="o">=</span> <span class="s1">'{{site.time | date: '</span><span class="o">%</span><span class="nx">Y</span><span class="o">%</span><span class="nx">m</span><span class="o">%</span><span class="nx">d</span><span class="o">%</span><span class="nx">H</span><span class="o">%</span><span class="nx">M</span><span class="o">%</span><span class="nx">S</span><span class="s1">'}}'</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">cacheName</span> <span class="o">=</span> <span class="s2">`static::</span><span class="p">${</span><span class="nx">version</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span></code></pre></figure><p>If you’re curious to see everything together, you can view my <a href="https://github.com/alexgibson/alxgbsn.co.uk/blob/master/sw.js">full service worker code here</a>.</p></section></article><footer role="contentinfo"><form role="search" class="search" action="https://duckduckgo.com/" method="get" title="Search this site"><label for="q">Search</label> <input type="hidden" name="sites" value="alxgbsn.co.uk"> <input class="search" type="search" name="q" id="q" placeholder="Search this site"> <button type="submit">Go</button></form><ul><li><a href="/feed/index.xml" title="RSS feed">Subscribe (RSS)</a></li></ul></footer></main><script type="module" src="/assets/theme-c123fb25e83dfa3f6932ea2db49aee4caa925d23bf05bed3593562542dd7fd66.js"></script><script type="module" src="/assets/main-e720254e216df6f38df9183d48fc5096b498cf7aa00bfdf57bf8aa71c31a7980.js"></script></body></html>